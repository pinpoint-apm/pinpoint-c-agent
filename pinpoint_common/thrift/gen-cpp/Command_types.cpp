/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Command_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTThreadDumpTypeValues[] = {
  TThreadDumpType::TARGET,
  TThreadDumpType::PENDING
};
const char* _kTThreadDumpTypeNames[] = {
  "TARGET",
  "PENDING"
};
const std::map<int, const char*> _TThreadDumpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTThreadDumpTypeValues, _kTThreadDumpTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TThreadDumpType::type& val) {
  std::map<int, const char*>::const_iterator it = _TThreadDumpType_VALUES_TO_NAMES.find(val);
  if (it != _TThreadDumpType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTThreadStateValues[] = {
  TThreadState::NEW,
  TThreadState::RUNNABLE,
  TThreadState::BLOCKED,
  TThreadState::WAITING,
  TThreadState::TIMED_WAITING,
  TThreadState::TERMINATED
};
const char* _kTThreadStateNames[] = {
  "NEW",
  "RUNNABLE",
  "BLOCKED",
  "WAITING",
  "TIMED_WAITING",
  "TERMINATED"
};
const std::map<int, const char*> _TThreadState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTThreadStateValues, _kTThreadStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TThreadState::type& val) {
  std::map<int, const char*>::const_iterator it = _TThreadState_VALUES_TO_NAMES.find(val);
  if (it != _TThreadState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRouteResultValues[] = {
  TRouteResult::OK,
  TRouteResult::BAD_REQUEST,
  TRouteResult::EMPTY_REQUEST,
  TRouteResult::NOT_SUPPORTED_REQUEST,
  TRouteResult::BAD_RESPONSE,
  TRouteResult::EMPTY_RESPONSE,
  TRouteResult::NOT_SUPPORTED_RESPONSE,
  TRouteResult::TIMEOUT,
  TRouteResult::NOT_FOUND,
  TRouteResult::NOT_ACCEPTABLE,
  TRouteResult::NOT_SUPPORTED_SERVICE,
  TRouteResult::UNKNOWN
};
const char* _kTRouteResultNames[] = {
  "OK",
  "BAD_REQUEST",
  "EMPTY_REQUEST",
  "NOT_SUPPORTED_REQUEST",
  "BAD_RESPONSE",
  "EMPTY_RESPONSE",
  "NOT_SUPPORTED_RESPONSE",
  "TIMEOUT",
  "NOT_FOUND",
  "NOT_ACCEPTABLE",
  "NOT_SUPPORTED_SERVICE",
  "UNKNOWN"
};
const std::map<int, const char*> _TRouteResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kTRouteResultValues, _kTRouteResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRouteResult::type& val) {
  std::map<int, const char*>::const_iterator it = _TRouteResult_VALUES_TO_NAMES.find(val);
  if (it != _TRouteResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TCommandThreadDump::~TCommandThreadDump() throw() {
}


void TCommandThreadDump::__set_type(const TThreadDumpType::type val) {
  this->type = val;
}

void TCommandThreadDump::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void TCommandThreadDump::__set_pendingTimeMillis(const int64_t val) {
  this->pendingTimeMillis = val;
__isset.pendingTimeMillis = true;
}
std::ostream& operator<<(std::ostream& out, const TCommandThreadDump& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCommandThreadDump::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TThreadDumpType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pendingTimeMillis);
          this->__isset.pendingTimeMillis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommandThreadDump::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommandThreadDump");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pendingTimeMillis) {
    xfer += oprot->writeFieldBegin("pendingTimeMillis", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->pendingTimeMillis);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommandThreadDump &a, TCommandThreadDump &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.name, b.name);
  swap(a.pendingTimeMillis, b.pendingTimeMillis);
  swap(a.__isset, b.__isset);
}

TCommandThreadDump::TCommandThreadDump(const TCommandThreadDump& other1) {
  type = other1.type;
  name = other1.name;
  pendingTimeMillis = other1.pendingTimeMillis;
  __isset = other1.__isset;
}
TCommandThreadDump& TCommandThreadDump::operator=(const TCommandThreadDump& other2) {
  type = other2.type;
  name = other2.name;
  pendingTimeMillis = other2.pendingTimeMillis;
  __isset = other2.__isset;
  return *this;
}
void TCommandThreadDump::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommandThreadDump(";
  out << "type=" << to_string(type);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "pendingTimeMillis="; (__isset.pendingTimeMillis ? (out << to_string(pendingTimeMillis)) : (out << "<null>"));
  out << ")";
}


TMonitorInfo::~TMonitorInfo() throw() {
}


void TMonitorInfo::__set_stackDepth(const int32_t val) {
  this->stackDepth = val;
}

void TMonitorInfo::__set_stackFrame(const std::string& val) {
  this->stackFrame = val;
}
std::ostream& operator<<(std::ostream& out, const TMonitorInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMonitorInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stackDepth);
          this->__isset.stackDepth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stackFrame);
          this->__isset.stackFrame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMonitorInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMonitorInfo");

  xfer += oprot->writeFieldBegin("stackDepth", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stackDepth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stackFrame", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->stackFrame);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMonitorInfo &a, TMonitorInfo &b) {
  using ::std::swap;
  swap(a.stackDepth, b.stackDepth);
  swap(a.stackFrame, b.stackFrame);
  swap(a.__isset, b.__isset);
}

TMonitorInfo::TMonitorInfo(const TMonitorInfo& other3) {
  stackDepth = other3.stackDepth;
  stackFrame = other3.stackFrame;
  __isset = other3.__isset;
}
TMonitorInfo& TMonitorInfo::operator=(const TMonitorInfo& other4) {
  stackDepth = other4.stackDepth;
  stackFrame = other4.stackFrame;
  __isset = other4.__isset;
  return *this;
}
void TMonitorInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMonitorInfo(";
  out << "stackDepth=" << to_string(stackDepth);
  out << ", " << "stackFrame=" << to_string(stackFrame);
  out << ")";
}


TThreadDump::~TThreadDump() throw() {
}


void TThreadDump::__set_threadName(const std::string& val) {
  this->threadName = val;
}

void TThreadDump::__set_threadId(const int64_t val) {
  this->threadId = val;
}

void TThreadDump::__set_blockedTime(const int64_t val) {
  this->blockedTime = val;
}

void TThreadDump::__set_blockedCount(const int64_t val) {
  this->blockedCount = val;
}

void TThreadDump::__set_waitedTime(const int64_t val) {
  this->waitedTime = val;
}

void TThreadDump::__set_waitedCount(const int64_t val) {
  this->waitedCount = val;
}

void TThreadDump::__set_lockName(const std::string& val) {
  this->lockName = val;
}

void TThreadDump::__set_lockOwnerId(const int64_t val) {
  this->lockOwnerId = val;
}

void TThreadDump::__set_lockOwnerName(const std::string& val) {
  this->lockOwnerName = val;
}

void TThreadDump::__set_inNative(const bool val) {
  this->inNative = val;
}

void TThreadDump::__set_suspended(const bool val) {
  this->suspended = val;
}

void TThreadDump::__set_threadState(const TThreadState::type val) {
  this->threadState = val;
}

void TThreadDump::__set_stackTrace(const std::vector<std::string> & val) {
  this->stackTrace = val;
}

void TThreadDump::__set_lockedMonitors(const std::vector<TMonitorInfo> & val) {
  this->lockedMonitors = val;
}

void TThreadDump::__set_lockedSynchronizers(const std::vector<std::string> & val) {
  this->lockedSynchronizers = val;
}
std::ostream& operator<<(std::ostream& out, const TThreadDump& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TThreadDump::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadName);
          this->__isset.threadName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->threadId);
          this->__isset.threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedTime);
          this->__isset.blockedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedCount);
          this->__isset.blockedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->waitedTime);
          this->__isset.waitedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->waitedCount);
          this->__isset.waitedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lockName);
          this->__isset.lockName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockOwnerId);
          this->__isset.lockOwnerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lockOwnerName);
          this->__isset.lockOwnerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inNative);
          this->__isset.inNative = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->suspended);
          this->__isset.suspended = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->threadState = (TThreadState::type)ecast5;
          this->__isset.threadState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stackTrace.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->stackTrace.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->stackTrace[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stackTrace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lockedMonitors.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->lockedMonitors.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->lockedMonitors[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lockedMonitors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lockedSynchronizers.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->lockedSynchronizers.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->lockedSynchronizers[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lockedSynchronizers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TThreadDump::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TThreadDump");

  xfer += oprot->writeFieldBegin("threadName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->threadId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockedTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->blockedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockedCount", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->blockedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitedTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->waitedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitedCount", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->waitedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lockName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->lockName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lockOwnerId", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lockOwnerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lockOwnerName", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->lockOwnerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inNative", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->inNative);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("suspended", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->suspended);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threadState", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->threadState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stackTrace", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stackTrace.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->stackTrace.begin(); _iter21 != this->stackTrace.end(); ++_iter21)
    {
      xfer += oprot->writeString((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lockedMonitors", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lockedMonitors.size()));
    std::vector<TMonitorInfo> ::const_iterator _iter22;
    for (_iter22 = this->lockedMonitors.begin(); _iter22 != this->lockedMonitors.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lockedSynchronizers", ::apache::thrift::protocol::T_LIST, 15);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->lockedSynchronizers.size()));
    std::vector<std::string> ::const_iterator _iter23;
    for (_iter23 = this->lockedSynchronizers.begin(); _iter23 != this->lockedSynchronizers.end(); ++_iter23)
    {
      xfer += oprot->writeString((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TThreadDump &a, TThreadDump &b) {
  using ::std::swap;
  swap(a.threadName, b.threadName);
  swap(a.threadId, b.threadId);
  swap(a.blockedTime, b.blockedTime);
  swap(a.blockedCount, b.blockedCount);
  swap(a.waitedTime, b.waitedTime);
  swap(a.waitedCount, b.waitedCount);
  swap(a.lockName, b.lockName);
  swap(a.lockOwnerId, b.lockOwnerId);
  swap(a.lockOwnerName, b.lockOwnerName);
  swap(a.inNative, b.inNative);
  swap(a.suspended, b.suspended);
  swap(a.threadState, b.threadState);
  swap(a.stackTrace, b.stackTrace);
  swap(a.lockedMonitors, b.lockedMonitors);
  swap(a.lockedSynchronizers, b.lockedSynchronizers);
  swap(a.__isset, b.__isset);
}

TThreadDump::TThreadDump(const TThreadDump& other24) {
  threadName = other24.threadName;
  threadId = other24.threadId;
  blockedTime = other24.blockedTime;
  blockedCount = other24.blockedCount;
  waitedTime = other24.waitedTime;
  waitedCount = other24.waitedCount;
  lockName = other24.lockName;
  lockOwnerId = other24.lockOwnerId;
  lockOwnerName = other24.lockOwnerName;
  inNative = other24.inNative;
  suspended = other24.suspended;
  threadState = other24.threadState;
  stackTrace = other24.stackTrace;
  lockedMonitors = other24.lockedMonitors;
  lockedSynchronizers = other24.lockedSynchronizers;
  __isset = other24.__isset;
}
TThreadDump& TThreadDump::operator=(const TThreadDump& other25) {
  threadName = other25.threadName;
  threadId = other25.threadId;
  blockedTime = other25.blockedTime;
  blockedCount = other25.blockedCount;
  waitedTime = other25.waitedTime;
  waitedCount = other25.waitedCount;
  lockName = other25.lockName;
  lockOwnerId = other25.lockOwnerId;
  lockOwnerName = other25.lockOwnerName;
  inNative = other25.inNative;
  suspended = other25.suspended;
  threadState = other25.threadState;
  stackTrace = other25.stackTrace;
  lockedMonitors = other25.lockedMonitors;
  lockedSynchronizers = other25.lockedSynchronizers;
  __isset = other25.__isset;
  return *this;
}
void TThreadDump::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TThreadDump(";
  out << "threadName=" << to_string(threadName);
  out << ", " << "threadId=" << to_string(threadId);
  out << ", " << "blockedTime=" << to_string(blockedTime);
  out << ", " << "blockedCount=" << to_string(blockedCount);
  out << ", " << "waitedTime=" << to_string(waitedTime);
  out << ", " << "waitedCount=" << to_string(waitedCount);
  out << ", " << "lockName=" << to_string(lockName);
  out << ", " << "lockOwnerId=" << to_string(lockOwnerId);
  out << ", " << "lockOwnerName=" << to_string(lockOwnerName);
  out << ", " << "inNative=" << to_string(inNative);
  out << ", " << "suspended=" << to_string(suspended);
  out << ", " << "threadState=" << to_string(threadState);
  out << ", " << "stackTrace=" << to_string(stackTrace);
  out << ", " << "lockedMonitors=" << to_string(lockedMonitors);
  out << ", " << "lockedSynchronizers=" << to_string(lockedSynchronizers);
  out << ")";
}


TCommandThreadDumpResponse::~TCommandThreadDumpResponse() throw() {
}


void TCommandThreadDumpResponse::__set_threadDumps(const std::vector<TThreadDump> & val) {
  this->threadDumps = val;
}
std::ostream& operator<<(std::ostream& out, const TCommandThreadDumpResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCommandThreadDumpResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->threadDumps.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->threadDumps.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->threadDumps[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.threadDumps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommandThreadDumpResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommandThreadDumpResponse");

  xfer += oprot->writeFieldBegin("threadDumps", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->threadDumps.size()));
    std::vector<TThreadDump> ::const_iterator _iter31;
    for (_iter31 = this->threadDumps.begin(); _iter31 != this->threadDumps.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommandThreadDumpResponse &a, TCommandThreadDumpResponse &b) {
  using ::std::swap;
  swap(a.threadDumps, b.threadDumps);
  swap(a.__isset, b.__isset);
}

TCommandThreadDumpResponse::TCommandThreadDumpResponse(const TCommandThreadDumpResponse& other32) {
  threadDumps = other32.threadDumps;
  __isset = other32.__isset;
}
TCommandThreadDumpResponse& TCommandThreadDumpResponse::operator=(const TCommandThreadDumpResponse& other33) {
  threadDumps = other33.threadDumps;
  __isset = other33.__isset;
  return *this;
}
void TCommandThreadDumpResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommandThreadDumpResponse(";
  out << "threadDumps=" << to_string(threadDumps);
  out << ")";
}


TCmdActiveThreadCount::~TCmdActiveThreadCount() throw() {
}

std::ostream& operator<<(std::ostream& out, const TCmdActiveThreadCount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCmdActiveThreadCount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCmdActiveThreadCount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCmdActiveThreadCount");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCmdActiveThreadCount &a, TCmdActiveThreadCount &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TCmdActiveThreadCount::TCmdActiveThreadCount(const TCmdActiveThreadCount& other34) {
  (void) other34;
}
TCmdActiveThreadCount& TCmdActiveThreadCount::operator=(const TCmdActiveThreadCount& other35) {
  (void) other35;
  return *this;
}
void TCmdActiveThreadCount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCmdActiveThreadCount(";
  out << ")";
}


TCmdActiveThreadCountRes::~TCmdActiveThreadCountRes() throw() {
}


void TCmdActiveThreadCountRes::__set_histogramSchemaType(const int32_t val) {
  this->histogramSchemaType = val;
}

void TCmdActiveThreadCountRes::__set_activeThreadCount(const std::vector<int32_t> & val) {
  this->activeThreadCount = val;
}

void TCmdActiveThreadCountRes::__set_timeStamp(const int64_t val) {
  this->timeStamp = val;
__isset.timeStamp = true;
}
std::ostream& operator<<(std::ostream& out, const TCmdActiveThreadCountRes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCmdActiveThreadCountRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->histogramSchemaType);
          this->__isset.histogramSchemaType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activeThreadCount.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->activeThreadCount.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI32(this->activeThreadCount[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.activeThreadCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeStamp);
          this->__isset.timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCmdActiveThreadCountRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCmdActiveThreadCountRes");

  xfer += oprot->writeFieldBegin("histogramSchemaType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->histogramSchemaType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("activeThreadCount", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->activeThreadCount.size()));
    std::vector<int32_t> ::const_iterator _iter41;
    for (_iter41 = this->activeThreadCount.begin(); _iter41 != this->activeThreadCount.end(); ++_iter41)
    {
      xfer += oprot->writeI32((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timeStamp) {
    xfer += oprot->writeFieldBegin("timeStamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timeStamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCmdActiveThreadCountRes &a, TCmdActiveThreadCountRes &b) {
  using ::std::swap;
  swap(a.histogramSchemaType, b.histogramSchemaType);
  swap(a.activeThreadCount, b.activeThreadCount);
  swap(a.timeStamp, b.timeStamp);
  swap(a.__isset, b.__isset);
}

TCmdActiveThreadCountRes::TCmdActiveThreadCountRes(const TCmdActiveThreadCountRes& other42) {
  histogramSchemaType = other42.histogramSchemaType;
  activeThreadCount = other42.activeThreadCount;
  timeStamp = other42.timeStamp;
  __isset = other42.__isset;
}
TCmdActiveThreadCountRes& TCmdActiveThreadCountRes::operator=(const TCmdActiveThreadCountRes& other43) {
  histogramSchemaType = other43.histogramSchemaType;
  activeThreadCount = other43.activeThreadCount;
  timeStamp = other43.timeStamp;
  __isset = other43.__isset;
  return *this;
}
void TCmdActiveThreadCountRes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCmdActiveThreadCountRes(";
  out << "histogramSchemaType=" << to_string(histogramSchemaType);
  out << ", " << "activeThreadCount=" << to_string(activeThreadCount);
  out << ", " << "timeStamp="; (__isset.timeStamp ? (out << to_string(timeStamp)) : (out << "<null>"));
  out << ")";
}


TActiveThreadDump::~TActiveThreadDump() throw() {
}


void TActiveThreadDump::__set_execTime(const int64_t val) {
  this->execTime = val;
}

void TActiveThreadDump::__set_threadDump(const TThreadDump& val) {
  this->threadDump = val;
}
std::ostream& operator<<(std::ostream& out, const TActiveThreadDump& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TActiveThreadDump::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execTime);
          this->__isset.execTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->threadDump.read(iprot);
          this->__isset.threadDump = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TActiveThreadDump::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TActiveThreadDump");

  xfer += oprot->writeFieldBegin("execTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->execTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threadDump", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->threadDump.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TActiveThreadDump &a, TActiveThreadDump &b) {
  using ::std::swap;
  swap(a.execTime, b.execTime);
  swap(a.threadDump, b.threadDump);
  swap(a.__isset, b.__isset);
}

TActiveThreadDump::TActiveThreadDump(const TActiveThreadDump& other44) {
  execTime = other44.execTime;
  threadDump = other44.threadDump;
  __isset = other44.__isset;
}
TActiveThreadDump& TActiveThreadDump::operator=(const TActiveThreadDump& other45) {
  execTime = other45.execTime;
  threadDump = other45.threadDump;
  __isset = other45.__isset;
  return *this;
}
void TActiveThreadDump::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TActiveThreadDump(";
  out << "execTime=" << to_string(execTime);
  out << ", " << "threadDump=" << to_string(threadDump);
  out << ")";
}


TCmdActiveThreadDump::~TCmdActiveThreadDump() throw() {
}


void TCmdActiveThreadDump::__set_execTime(const int64_t val) {
  this->execTime = val;
__isset.execTime = true;
}
std::ostream& operator<<(std::ostream& out, const TCmdActiveThreadDump& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCmdActiveThreadDump::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execTime);
          this->__isset.execTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCmdActiveThreadDump::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCmdActiveThreadDump");

  if (this->__isset.execTime) {
    xfer += oprot->writeFieldBegin("execTime", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->execTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCmdActiveThreadDump &a, TCmdActiveThreadDump &b) {
  using ::std::swap;
  swap(a.execTime, b.execTime);
  swap(a.__isset, b.__isset);
}

TCmdActiveThreadDump::TCmdActiveThreadDump(const TCmdActiveThreadDump& other46) {
  execTime = other46.execTime;
  __isset = other46.__isset;
}
TCmdActiveThreadDump& TCmdActiveThreadDump::operator=(const TCmdActiveThreadDump& other47) {
  execTime = other47.execTime;
  __isset = other47.__isset;
  return *this;
}
void TCmdActiveThreadDump::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCmdActiveThreadDump(";
  out << "execTime="; (__isset.execTime ? (out << to_string(execTime)) : (out << "<null>"));
  out << ")";
}


TCmdActiveThreadDumpRes::~TCmdActiveThreadDumpRes() throw() {
}


void TCmdActiveThreadDumpRes::__set_threadDumps(const std::vector<TActiveThreadDump> & val) {
  this->threadDumps = val;
}
std::ostream& operator<<(std::ostream& out, const TCmdActiveThreadDumpRes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCmdActiveThreadDumpRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->threadDumps.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->threadDumps.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->threadDumps[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.threadDumps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCmdActiveThreadDumpRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCmdActiveThreadDumpRes");

  xfer += oprot->writeFieldBegin("threadDumps", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->threadDumps.size()));
    std::vector<TActiveThreadDump> ::const_iterator _iter53;
    for (_iter53 = this->threadDumps.begin(); _iter53 != this->threadDumps.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCmdActiveThreadDumpRes &a, TCmdActiveThreadDumpRes &b) {
  using ::std::swap;
  swap(a.threadDumps, b.threadDumps);
  swap(a.__isset, b.__isset);
}

TCmdActiveThreadDumpRes::TCmdActiveThreadDumpRes(const TCmdActiveThreadDumpRes& other54) {
  threadDumps = other54.threadDumps;
  __isset = other54.__isset;
}
TCmdActiveThreadDumpRes& TCmdActiveThreadDumpRes::operator=(const TCmdActiveThreadDumpRes& other55) {
  threadDumps = other55.threadDumps;
  __isset = other55.__isset;
  return *this;
}
void TCmdActiveThreadDumpRes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCmdActiveThreadDumpRes(";
  out << "threadDumps=" << to_string(threadDumps);
  out << ")";
}


TCommandEcho::~TCommandEcho() throw() {
}


void TCommandEcho::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TCommandEcho& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCommandEcho::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommandEcho::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommandEcho");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommandEcho &a, TCommandEcho &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TCommandEcho::TCommandEcho(const TCommandEcho& other56) {
  message = other56.message;
  __isset = other56.__isset;
}
TCommandEcho& TCommandEcho::operator=(const TCommandEcho& other57) {
  message = other57.message;
  __isset = other57.__isset;
  return *this;
}
void TCommandEcho::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommandEcho(";
  out << "message=" << to_string(message);
  out << ")";
}


TCommandTransfer::~TCommandTransfer() throw() {
}


void TCommandTransfer::__set_applicationName(const std::string& val) {
  this->applicationName = val;
}

void TCommandTransfer::__set_agentId(const std::string& val) {
  this->agentId = val;
}

void TCommandTransfer::__set_startTime(const int64_t val) {
  this->startTime = val;
__isset.startTime = true;
}

void TCommandTransfer::__set_payload(const std::string& val) {
  this->payload = val;
}
std::ostream& operator<<(std::ostream& out, const TCommandTransfer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCommandTransfer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationName);
          this->__isset.applicationName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentId);
          this->__isset.agentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommandTransfer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommandTransfer");

  xfer += oprot->writeFieldBegin("applicationName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->applicationName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agentId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->agentId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startTime) {
    xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommandTransfer &a, TCommandTransfer &b) {
  using ::std::swap;
  swap(a.applicationName, b.applicationName);
  swap(a.agentId, b.agentId);
  swap(a.startTime, b.startTime);
  swap(a.payload, b.payload);
  swap(a.__isset, b.__isset);
}

TCommandTransfer::TCommandTransfer(const TCommandTransfer& other58) {
  applicationName = other58.applicationName;
  agentId = other58.agentId;
  startTime = other58.startTime;
  payload = other58.payload;
  __isset = other58.__isset;
}
TCommandTransfer& TCommandTransfer::operator=(const TCommandTransfer& other59) {
  applicationName = other59.applicationName;
  agentId = other59.agentId;
  startTime = other59.startTime;
  payload = other59.payload;
  __isset = other59.__isset;
  return *this;
}
void TCommandTransfer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommandTransfer(";
  out << "applicationName=" << to_string(applicationName);
  out << ", " << "agentId=" << to_string(agentId);
  out << ", " << "startTime="; (__isset.startTime ? (out << to_string(startTime)) : (out << "<null>"));
  out << ", " << "payload=" << to_string(payload);
  out << ")";
}


TCommandTransferResponse::~TCommandTransferResponse() throw() {
}


void TCommandTransferResponse::__set_routeResult(const TRouteResult::type val) {
  this->routeResult = val;
}

void TCommandTransferResponse::__set_payload(const std::string& val) {
  this->payload = val;
}

void TCommandTransferResponse::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TCommandTransferResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCommandTransferResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->routeResult = (TRouteResult::type)ecast60;
          this->__isset.routeResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommandTransferResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommandTransferResponse");

  xfer += oprot->writeFieldBegin("routeResult", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->routeResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommandTransferResponse &a, TCommandTransferResponse &b) {
  using ::std::swap;
  swap(a.routeResult, b.routeResult);
  swap(a.payload, b.payload);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TCommandTransferResponse::TCommandTransferResponse(const TCommandTransferResponse& other61) {
  routeResult = other61.routeResult;
  payload = other61.payload;
  message = other61.message;
  __isset = other61.__isset;
}
TCommandTransferResponse& TCommandTransferResponse::operator=(const TCommandTransferResponse& other62) {
  routeResult = other62.routeResult;
  payload = other62.payload;
  message = other62.message;
  __isset = other62.__isset;
  return *this;
}
void TCommandTransferResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommandTransferResponse(";
  out << "routeResult=" << to_string(routeResult);
  out << ", " << "payload=" << to_string(payload);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}


