/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Pinpoint_TYPES_H
#define Pinpoint_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>




struct TJvmGcType {
  enum type {
    UNKNOWN = 0,
    SERIAL = 1,
    PARALLEL = 2,
    CMS = 3,
    G1 = 4
  };
};

extern const std::map<int, const char*> _TJvmGcType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TJvmGcType::type& val);

class TServiceInfo;

class TServerMetaData;

class TJvmInfo;

class TAgentInfo;

class TJvmGcDetailed;

class TJvmGc;

class TCpuLoad;

class TTransaction;

class TActiveTraceHistogram;

class TActiveTrace;

class TAgentStat;

class TAgentStatBatch;

typedef struct _TServiceInfo__isset {
  _TServiceInfo__isset() : serviceName(false), serviceLibs(false) {}
  bool serviceName :1;
  bool serviceLibs :1;
} _TServiceInfo__isset;

class TServiceInfo : public virtual ::apache::thrift::TBase {
 public:

  TServiceInfo(const TServiceInfo&);
  TServiceInfo& operator=(const TServiceInfo&);
  TServiceInfo() : serviceName() {
  }

  virtual ~TServiceInfo() throw();
  std::string serviceName;
  std::vector<std::string>  serviceLibs;

  _TServiceInfo__isset __isset;

  void __set_serviceName(const std::string& val);

  void __set_serviceLibs(const std::vector<std::string> & val);

  bool operator == (const TServiceInfo & rhs) const
  {
    if (__isset.serviceName != rhs.__isset.serviceName)
      return false;
    else if (__isset.serviceName && !(serviceName == rhs.serviceName))
      return false;
    if (__isset.serviceLibs != rhs.__isset.serviceLibs)
      return false;
    else if (__isset.serviceLibs && !(serviceLibs == rhs.serviceLibs))
      return false;
    return true;
  }
  bool operator != (const TServiceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TServiceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TServiceInfo &a, TServiceInfo &b);

std::ostream& operator<<(std::ostream& out, const TServiceInfo& obj);

typedef struct _TServerMetaData__isset {
  _TServerMetaData__isset() : serverInfo(false), vmArgs(false), serviceInfos(false) {}
  bool serverInfo :1;
  bool vmArgs :1;
  bool serviceInfos :1;
} _TServerMetaData__isset;

class TServerMetaData : public virtual ::apache::thrift::TBase {
 public:

  TServerMetaData(const TServerMetaData&);
  TServerMetaData& operator=(const TServerMetaData&);
  TServerMetaData() : serverInfo() {
  }

  virtual ~TServerMetaData() throw();
  std::string serverInfo;
  std::vector<std::string>  vmArgs;
  std::vector<TServiceInfo>  serviceInfos;

  _TServerMetaData__isset __isset;

  void __set_serverInfo(const std::string& val);

  void __set_vmArgs(const std::vector<std::string> & val);

  void __set_serviceInfos(const std::vector<TServiceInfo> & val);

  bool operator == (const TServerMetaData & rhs) const
  {
    if (__isset.serverInfo != rhs.__isset.serverInfo)
      return false;
    else if (__isset.serverInfo && !(serverInfo == rhs.serverInfo))
      return false;
    if (__isset.vmArgs != rhs.__isset.vmArgs)
      return false;
    else if (__isset.vmArgs && !(vmArgs == rhs.vmArgs))
      return false;
    if (__isset.serviceInfos != rhs.__isset.serviceInfos)
      return false;
    else if (__isset.serviceInfos && !(serviceInfos == rhs.serviceInfos))
      return false;
    return true;
  }
  bool operator != (const TServerMetaData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TServerMetaData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TServerMetaData &a, TServerMetaData &b);

std::ostream& operator<<(std::ostream& out, const TServerMetaData& obj);

typedef struct _TJvmInfo__isset {
  _TJvmInfo__isset() : version(true), vmVersion(false), gcType(true) {}
  bool version :1;
  bool vmVersion :1;
  bool gcType :1;
} _TJvmInfo__isset;

class TJvmInfo : public virtual ::apache::thrift::TBase {
 public:

  TJvmInfo(const TJvmInfo&);
  TJvmInfo& operator=(const TJvmInfo&);
  TJvmInfo() : version(0), vmVersion(), gcType((TJvmGcType::type)0) {
    gcType = (TJvmGcType::type)0;

  }

  virtual ~TJvmInfo() throw();
  int16_t version;
  std::string vmVersion;
  TJvmGcType::type gcType;

  _TJvmInfo__isset __isset;

  void __set_version(const int16_t val);

  void __set_vmVersion(const std::string& val);

  void __set_gcType(const TJvmGcType::type val);

  bool operator == (const TJvmInfo & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (__isset.vmVersion != rhs.__isset.vmVersion)
      return false;
    else if (__isset.vmVersion && !(vmVersion == rhs.vmVersion))
      return false;
    if (__isset.gcType != rhs.__isset.gcType)
      return false;
    else if (__isset.gcType && !(gcType == rhs.gcType))
      return false;
    return true;
  }
  bool operator != (const TJvmInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TJvmInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJvmInfo &a, TJvmInfo &b);

std::ostream& operator<<(std::ostream& out, const TJvmInfo& obj);

typedef struct _TAgentInfo__isset {
  _TAgentInfo__isset() : hostname(false), ip(false), ports(false), agentId(false), applicationName(false), serviceType(false), pid(false), agentVersion(false), vmVersion(false), startTimestamp(false), endTimestamp(false), endStatus(false), serverMetaData(false), jvmInfo(false) {}
  bool hostname :1;
  bool ip :1;
  bool ports :1;
  bool agentId :1;
  bool applicationName :1;
  bool serviceType :1;
  bool pid :1;
  bool agentVersion :1;
  bool vmVersion :1;
  bool startTimestamp :1;
  bool endTimestamp :1;
  bool endStatus :1;
  bool serverMetaData :1;
  bool jvmInfo :1;
} _TAgentInfo__isset;

class TAgentInfo : public virtual ::apache::thrift::TBase {
 public:

  TAgentInfo(const TAgentInfo&);
  TAgentInfo& operator=(const TAgentInfo&);
  TAgentInfo() : hostname(), ip(), ports(), agentId(), applicationName(), serviceType(0), pid(0), agentVersion(), vmVersion(), startTimestamp(0), endTimestamp(0), endStatus(0) {
  }

  virtual ~TAgentInfo() throw();
  std::string hostname;
  std::string ip;
  std::string ports;
  std::string agentId;
  std::string applicationName;
  int16_t serviceType;
  int32_t pid;
  std::string agentVersion;
  std::string vmVersion;
  int64_t startTimestamp;
  int64_t endTimestamp;
  int32_t endStatus;
  TServerMetaData serverMetaData;
  TJvmInfo jvmInfo;

  _TAgentInfo__isset __isset;

  void __set_hostname(const std::string& val);

  void __set_ip(const std::string& val);

  void __set_ports(const std::string& val);

  void __set_agentId(const std::string& val);

  void __set_applicationName(const std::string& val);

  void __set_serviceType(const int16_t val);

  void __set_pid(const int32_t val);

  void __set_agentVersion(const std::string& val);

  void __set_vmVersion(const std::string& val);

  void __set_startTimestamp(const int64_t val);

  void __set_endTimestamp(const int64_t val);

  void __set_endStatus(const int32_t val);

  void __set_serverMetaData(const TServerMetaData& val);

  void __set_jvmInfo(const TJvmInfo& val);

  bool operator == (const TAgentInfo & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(ports == rhs.ports))
      return false;
    if (!(agentId == rhs.agentId))
      return false;
    if (!(applicationName == rhs.applicationName))
      return false;
    if (!(serviceType == rhs.serviceType))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(agentVersion == rhs.agentVersion))
      return false;
    if (!(vmVersion == rhs.vmVersion))
      return false;
    if (!(startTimestamp == rhs.startTimestamp))
      return false;
    if (__isset.endTimestamp != rhs.__isset.endTimestamp)
      return false;
    else if (__isset.endTimestamp && !(endTimestamp == rhs.endTimestamp))
      return false;
    if (__isset.endStatus != rhs.__isset.endStatus)
      return false;
    else if (__isset.endStatus && !(endStatus == rhs.endStatus))
      return false;
    if (__isset.serverMetaData != rhs.__isset.serverMetaData)
      return false;
    else if (__isset.serverMetaData && !(serverMetaData == rhs.serverMetaData))
      return false;
    if (__isset.jvmInfo != rhs.__isset.jvmInfo)
      return false;
    else if (__isset.jvmInfo && !(jvmInfo == rhs.jvmInfo))
      return false;
    return true;
  }
  bool operator != (const TAgentInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentInfo &a, TAgentInfo &b);

std::ostream& operator<<(std::ostream& out, const TAgentInfo& obj);

typedef struct _TJvmGcDetailed__isset {
  _TJvmGcDetailed__isset() : jvmGcNewCount(false), jvmGcNewTime(false), jvmPoolCodeCacheUsed(false), jvmPoolNewGenUsed(false), jvmPoolOldGenUsed(false), jvmPoolSurvivorSpaceUsed(false), jvmPoolPermGenUsed(false), jvmPoolMetaspaceUsed(false) {}
  bool jvmGcNewCount :1;
  bool jvmGcNewTime :1;
  bool jvmPoolCodeCacheUsed :1;
  bool jvmPoolNewGenUsed :1;
  bool jvmPoolOldGenUsed :1;
  bool jvmPoolSurvivorSpaceUsed :1;
  bool jvmPoolPermGenUsed :1;
  bool jvmPoolMetaspaceUsed :1;
} _TJvmGcDetailed__isset;

class TJvmGcDetailed : public virtual ::apache::thrift::TBase {
 public:

  TJvmGcDetailed(const TJvmGcDetailed&);
  TJvmGcDetailed& operator=(const TJvmGcDetailed&);
  TJvmGcDetailed() : jvmGcNewCount(0), jvmGcNewTime(0), jvmPoolCodeCacheUsed(0), jvmPoolNewGenUsed(0), jvmPoolOldGenUsed(0), jvmPoolSurvivorSpaceUsed(0), jvmPoolPermGenUsed(0), jvmPoolMetaspaceUsed(0) {
  }

  virtual ~TJvmGcDetailed() throw();
  int64_t jvmGcNewCount;
  int64_t jvmGcNewTime;
  double jvmPoolCodeCacheUsed;
  double jvmPoolNewGenUsed;
  double jvmPoolOldGenUsed;
  double jvmPoolSurvivorSpaceUsed;
  double jvmPoolPermGenUsed;
  double jvmPoolMetaspaceUsed;

  _TJvmGcDetailed__isset __isset;

  void __set_jvmGcNewCount(const int64_t val);

  void __set_jvmGcNewTime(const int64_t val);

  void __set_jvmPoolCodeCacheUsed(const double val);

  void __set_jvmPoolNewGenUsed(const double val);

  void __set_jvmPoolOldGenUsed(const double val);

  void __set_jvmPoolSurvivorSpaceUsed(const double val);

  void __set_jvmPoolPermGenUsed(const double val);

  void __set_jvmPoolMetaspaceUsed(const double val);

  bool operator == (const TJvmGcDetailed & rhs) const
  {
    if (__isset.jvmGcNewCount != rhs.__isset.jvmGcNewCount)
      return false;
    else if (__isset.jvmGcNewCount && !(jvmGcNewCount == rhs.jvmGcNewCount))
      return false;
    if (__isset.jvmGcNewTime != rhs.__isset.jvmGcNewTime)
      return false;
    else if (__isset.jvmGcNewTime && !(jvmGcNewTime == rhs.jvmGcNewTime))
      return false;
    if (__isset.jvmPoolCodeCacheUsed != rhs.__isset.jvmPoolCodeCacheUsed)
      return false;
    else if (__isset.jvmPoolCodeCacheUsed && !(jvmPoolCodeCacheUsed == rhs.jvmPoolCodeCacheUsed))
      return false;
    if (__isset.jvmPoolNewGenUsed != rhs.__isset.jvmPoolNewGenUsed)
      return false;
    else if (__isset.jvmPoolNewGenUsed && !(jvmPoolNewGenUsed == rhs.jvmPoolNewGenUsed))
      return false;
    if (__isset.jvmPoolOldGenUsed != rhs.__isset.jvmPoolOldGenUsed)
      return false;
    else if (__isset.jvmPoolOldGenUsed && !(jvmPoolOldGenUsed == rhs.jvmPoolOldGenUsed))
      return false;
    if (__isset.jvmPoolSurvivorSpaceUsed != rhs.__isset.jvmPoolSurvivorSpaceUsed)
      return false;
    else if (__isset.jvmPoolSurvivorSpaceUsed && !(jvmPoolSurvivorSpaceUsed == rhs.jvmPoolSurvivorSpaceUsed))
      return false;
    if (__isset.jvmPoolPermGenUsed != rhs.__isset.jvmPoolPermGenUsed)
      return false;
    else if (__isset.jvmPoolPermGenUsed && !(jvmPoolPermGenUsed == rhs.jvmPoolPermGenUsed))
      return false;
    if (__isset.jvmPoolMetaspaceUsed != rhs.__isset.jvmPoolMetaspaceUsed)
      return false;
    else if (__isset.jvmPoolMetaspaceUsed && !(jvmPoolMetaspaceUsed == rhs.jvmPoolMetaspaceUsed))
      return false;
    return true;
  }
  bool operator != (const TJvmGcDetailed &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TJvmGcDetailed & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJvmGcDetailed &a, TJvmGcDetailed &b);

std::ostream& operator<<(std::ostream& out, const TJvmGcDetailed& obj);

typedef struct _TJvmGc__isset {
  _TJvmGc__isset() : type(true), jvmMemoryHeapUsed(false), jvmMemoryHeapMax(false), jvmMemoryNonHeapUsed(false), jvmMemoryNonHeapMax(false), jvmGcOldCount(false), jvmGcOldTime(false), jvmGcDetailed(false) {}
  bool type :1;
  bool jvmMemoryHeapUsed :1;
  bool jvmMemoryHeapMax :1;
  bool jvmMemoryNonHeapUsed :1;
  bool jvmMemoryNonHeapMax :1;
  bool jvmGcOldCount :1;
  bool jvmGcOldTime :1;
  bool jvmGcDetailed :1;
} _TJvmGc__isset;

class TJvmGc : public virtual ::apache::thrift::TBase {
 public:

  TJvmGc(const TJvmGc&);
  TJvmGc& operator=(const TJvmGc&);
  TJvmGc() : type((TJvmGcType::type)0), jvmMemoryHeapUsed(0), jvmMemoryHeapMax(0), jvmMemoryNonHeapUsed(0), jvmMemoryNonHeapMax(0), jvmGcOldCount(0), jvmGcOldTime(0) {
    type = (TJvmGcType::type)0;

  }

  virtual ~TJvmGc() throw();
  TJvmGcType::type type;
  int64_t jvmMemoryHeapUsed;
  int64_t jvmMemoryHeapMax;
  int64_t jvmMemoryNonHeapUsed;
  int64_t jvmMemoryNonHeapMax;
  int64_t jvmGcOldCount;
  int64_t jvmGcOldTime;
  TJvmGcDetailed jvmGcDetailed;

  _TJvmGc__isset __isset;

  void __set_type(const TJvmGcType::type val);

  void __set_jvmMemoryHeapUsed(const int64_t val);

  void __set_jvmMemoryHeapMax(const int64_t val);

  void __set_jvmMemoryNonHeapUsed(const int64_t val);

  void __set_jvmMemoryNonHeapMax(const int64_t val);

  void __set_jvmGcOldCount(const int64_t val);

  void __set_jvmGcOldTime(const int64_t val);

  void __set_jvmGcDetailed(const TJvmGcDetailed& val);

  bool operator == (const TJvmGc & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(jvmMemoryHeapUsed == rhs.jvmMemoryHeapUsed))
      return false;
    if (!(jvmMemoryHeapMax == rhs.jvmMemoryHeapMax))
      return false;
    if (!(jvmMemoryNonHeapUsed == rhs.jvmMemoryNonHeapUsed))
      return false;
    if (!(jvmMemoryNonHeapMax == rhs.jvmMemoryNonHeapMax))
      return false;
    if (!(jvmGcOldCount == rhs.jvmGcOldCount))
      return false;
    if (!(jvmGcOldTime == rhs.jvmGcOldTime))
      return false;
    if (__isset.jvmGcDetailed != rhs.__isset.jvmGcDetailed)
      return false;
    else if (__isset.jvmGcDetailed && !(jvmGcDetailed == rhs.jvmGcDetailed))
      return false;
    return true;
  }
  bool operator != (const TJvmGc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TJvmGc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJvmGc &a, TJvmGc &b);

std::ostream& operator<<(std::ostream& out, const TJvmGc& obj);

typedef struct _TCpuLoad__isset {
  _TCpuLoad__isset() : jvmCpuLoad(false), systemCpuLoad(false) {}
  bool jvmCpuLoad :1;
  bool systemCpuLoad :1;
} _TCpuLoad__isset;

class TCpuLoad : public virtual ::apache::thrift::TBase {
 public:

  TCpuLoad(const TCpuLoad&);
  TCpuLoad& operator=(const TCpuLoad&);
  TCpuLoad() : jvmCpuLoad(0), systemCpuLoad(0) {
  }

  virtual ~TCpuLoad() throw();
  double jvmCpuLoad;
  double systemCpuLoad;

  _TCpuLoad__isset __isset;

  void __set_jvmCpuLoad(const double val);

  void __set_systemCpuLoad(const double val);

  bool operator == (const TCpuLoad & rhs) const
  {
    if (__isset.jvmCpuLoad != rhs.__isset.jvmCpuLoad)
      return false;
    else if (__isset.jvmCpuLoad && !(jvmCpuLoad == rhs.jvmCpuLoad))
      return false;
    if (__isset.systemCpuLoad != rhs.__isset.systemCpuLoad)
      return false;
    else if (__isset.systemCpuLoad && !(systemCpuLoad == rhs.systemCpuLoad))
      return false;
    return true;
  }
  bool operator != (const TCpuLoad &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCpuLoad & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCpuLoad &a, TCpuLoad &b);

std::ostream& operator<<(std::ostream& out, const TCpuLoad& obj);

typedef struct _TTransaction__isset {
  _TTransaction__isset() : sampledNewCount(false), sampledContinuationCount(false), unsampledNewCount(false), unsampledContinuationCount(false) {}
  bool sampledNewCount :1;
  bool sampledContinuationCount :1;
  bool unsampledNewCount :1;
  bool unsampledContinuationCount :1;
} _TTransaction__isset;

class TTransaction : public virtual ::apache::thrift::TBase {
 public:

  TTransaction(const TTransaction&);
  TTransaction& operator=(const TTransaction&);
  TTransaction() : sampledNewCount(0), sampledContinuationCount(0), unsampledNewCount(0), unsampledContinuationCount(0) {
  }

  virtual ~TTransaction() throw();
  int64_t sampledNewCount;
  int64_t sampledContinuationCount;
  int64_t unsampledNewCount;
  int64_t unsampledContinuationCount;

  _TTransaction__isset __isset;

  void __set_sampledNewCount(const int64_t val);

  void __set_sampledContinuationCount(const int64_t val);

  void __set_unsampledNewCount(const int64_t val);

  void __set_unsampledContinuationCount(const int64_t val);

  bool operator == (const TTransaction & rhs) const
  {
    if (__isset.sampledNewCount != rhs.__isset.sampledNewCount)
      return false;
    else if (__isset.sampledNewCount && !(sampledNewCount == rhs.sampledNewCount))
      return false;
    if (__isset.sampledContinuationCount != rhs.__isset.sampledContinuationCount)
      return false;
    else if (__isset.sampledContinuationCount && !(sampledContinuationCount == rhs.sampledContinuationCount))
      return false;
    if (__isset.unsampledNewCount != rhs.__isset.unsampledNewCount)
      return false;
    else if (__isset.unsampledNewCount && !(unsampledNewCount == rhs.unsampledNewCount))
      return false;
    if (__isset.unsampledContinuationCount != rhs.__isset.unsampledContinuationCount)
      return false;
    else if (__isset.unsampledContinuationCount && !(unsampledContinuationCount == rhs.unsampledContinuationCount))
      return false;
    return true;
  }
  bool operator != (const TTransaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTransaction &a, TTransaction &b);

std::ostream& operator<<(std::ostream& out, const TTransaction& obj);

typedef struct _TActiveTraceHistogram__isset {
  _TActiveTraceHistogram__isset() : version(true), histogramSchemaType(false), activeTraceCount(false) {}
  bool version :1;
  bool histogramSchemaType :1;
  bool activeTraceCount :1;
} _TActiveTraceHistogram__isset;

class TActiveTraceHistogram : public virtual ::apache::thrift::TBase {
 public:

  TActiveTraceHistogram(const TActiveTraceHistogram&);
  TActiveTraceHistogram& operator=(const TActiveTraceHistogram&);
  TActiveTraceHistogram() : version(0), histogramSchemaType(0) {
  }

  virtual ~TActiveTraceHistogram() throw();
  int16_t version;
  int32_t histogramSchemaType;
  std::vector<int32_t>  activeTraceCount;

  _TActiveTraceHistogram__isset __isset;

  void __set_version(const int16_t val);

  void __set_histogramSchemaType(const int32_t val);

  void __set_activeTraceCount(const std::vector<int32_t> & val);

  bool operator == (const TActiveTraceHistogram & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (__isset.histogramSchemaType != rhs.__isset.histogramSchemaType)
      return false;
    else if (__isset.histogramSchemaType && !(histogramSchemaType == rhs.histogramSchemaType))
      return false;
    if (__isset.activeTraceCount != rhs.__isset.activeTraceCount)
      return false;
    else if (__isset.activeTraceCount && !(activeTraceCount == rhs.activeTraceCount))
      return false;
    return true;
  }
  bool operator != (const TActiveTraceHistogram &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TActiveTraceHistogram & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TActiveTraceHistogram &a, TActiveTraceHistogram &b);

std::ostream& operator<<(std::ostream& out, const TActiveTraceHistogram& obj);

typedef struct _TActiveTrace__isset {
  _TActiveTrace__isset() : histogram(false) {}
  bool histogram :1;
} _TActiveTrace__isset;

class TActiveTrace : public virtual ::apache::thrift::TBase {
 public:

  TActiveTrace(const TActiveTrace&);
  TActiveTrace& operator=(const TActiveTrace&);
  TActiveTrace() {
  }

  virtual ~TActiveTrace() throw();
  TActiveTraceHistogram histogram;

  _TActiveTrace__isset __isset;

  void __set_histogram(const TActiveTraceHistogram& val);

  bool operator == (const TActiveTrace & rhs) const
  {
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const TActiveTrace &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TActiveTrace & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TActiveTrace &a, TActiveTrace &b);

std::ostream& operator<<(std::ostream& out, const TActiveTrace& obj);

typedef struct _TAgentStat__isset {
  _TAgentStat__isset() : agentId(false), startTimestamp(false), timestamp(false), collectInterval(false), gc(false), cpuLoad(false), transaction(false), activeTrace(false), metadata(false) {}
  bool agentId :1;
  bool startTimestamp :1;
  bool timestamp :1;
  bool collectInterval :1;
  bool gc :1;
  bool cpuLoad :1;
  bool transaction :1;
  bool activeTrace :1;
  bool metadata :1;
} _TAgentStat__isset;

class TAgentStat : public virtual ::apache::thrift::TBase {
 public:

  TAgentStat(const TAgentStat&);
  TAgentStat& operator=(const TAgentStat&);
  TAgentStat() : agentId(), startTimestamp(0), timestamp(0), collectInterval(0), metadata() {
  }

  virtual ~TAgentStat() throw();
  std::string agentId;
  int64_t startTimestamp;
  int64_t timestamp;
  int64_t collectInterval;
  TJvmGc gc;
  TCpuLoad cpuLoad;
  TTransaction transaction;
  TActiveTrace activeTrace;
  std::string metadata;

  _TAgentStat__isset __isset;

  void __set_agentId(const std::string& val);

  void __set_startTimestamp(const int64_t val);

  void __set_timestamp(const int64_t val);

  void __set_collectInterval(const int64_t val);

  void __set_gc(const TJvmGc& val);

  void __set_cpuLoad(const TCpuLoad& val);

  void __set_transaction(const TTransaction& val);

  void __set_activeTrace(const TActiveTrace& val);

  void __set_metadata(const std::string& val);

  bool operator == (const TAgentStat & rhs) const
  {
    if (__isset.agentId != rhs.__isset.agentId)
      return false;
    else if (__isset.agentId && !(agentId == rhs.agentId))
      return false;
    if (__isset.startTimestamp != rhs.__isset.startTimestamp)
      return false;
    else if (__isset.startTimestamp && !(startTimestamp == rhs.startTimestamp))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.collectInterval != rhs.__isset.collectInterval)
      return false;
    else if (__isset.collectInterval && !(collectInterval == rhs.collectInterval))
      return false;
    if (__isset.gc != rhs.__isset.gc)
      return false;
    else if (__isset.gc && !(gc == rhs.gc))
      return false;
    if (__isset.cpuLoad != rhs.__isset.cpuLoad)
      return false;
    else if (__isset.cpuLoad && !(cpuLoad == rhs.cpuLoad))
      return false;
    if (__isset.transaction != rhs.__isset.transaction)
      return false;
    else if (__isset.transaction && !(transaction == rhs.transaction))
      return false;
    if (__isset.activeTrace != rhs.__isset.activeTrace)
      return false;
    else if (__isset.activeTrace && !(activeTrace == rhs.activeTrace))
      return false;
    if (__isset.metadata != rhs.__isset.metadata)
      return false;
    else if (__isset.metadata && !(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const TAgentStat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentStat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentStat &a, TAgentStat &b);

std::ostream& operator<<(std::ostream& out, const TAgentStat& obj);

typedef struct _TAgentStatBatch__isset {
  _TAgentStatBatch__isset() : agentId(false), startTimestamp(false), agentStats(false) {}
  bool agentId :1;
  bool startTimestamp :1;
  bool agentStats :1;
} _TAgentStatBatch__isset;

class TAgentStatBatch : public virtual ::apache::thrift::TBase {
 public:

  TAgentStatBatch(const TAgentStatBatch&);
  TAgentStatBatch& operator=(const TAgentStatBatch&);
  TAgentStatBatch() : agentId(), startTimestamp(0) {
  }

  virtual ~TAgentStatBatch() throw();
  std::string agentId;
  int64_t startTimestamp;
  std::vector<TAgentStat>  agentStats;

  _TAgentStatBatch__isset __isset;

  void __set_agentId(const std::string& val);

  void __set_startTimestamp(const int64_t val);

  void __set_agentStats(const std::vector<TAgentStat> & val);

  bool operator == (const TAgentStatBatch & rhs) const
  {
    if (!(agentId == rhs.agentId))
      return false;
    if (!(startTimestamp == rhs.startTimestamp))
      return false;
    if (!(agentStats == rhs.agentStats))
      return false;
    return true;
  }
  bool operator != (const TAgentStatBatch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentStatBatch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentStatBatch &a, TAgentStatBatch &b);

std::ostream& operator<<(std::ostream& out, const TAgentStatBatch& obj);



#endif
