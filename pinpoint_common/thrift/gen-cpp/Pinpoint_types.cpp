/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Pinpoint_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTJvmGcTypeValues[] = {
  TJvmGcType::UNKNOWN,
  TJvmGcType::SERIAL,
  TJvmGcType::PARALLEL,
  TJvmGcType::CMS,
  TJvmGcType::G1
};
const char* _kTJvmGcTypeNames[] = {
  "UNKNOWN",
  "SERIAL",
  "PARALLEL",
  "CMS",
  "G1"
};
const std::map<int, const char*> _TJvmGcType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTJvmGcTypeValues, _kTJvmGcTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TJvmGcType::type& val) {
  std::map<int, const char*>::const_iterator it = _TJvmGcType_VALUES_TO_NAMES.find(val);
  if (it != _TJvmGcType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TServiceInfo::~TServiceInfo() throw() {
}


void TServiceInfo::__set_serviceName(const std::string& val) {
  this->serviceName = val;
__isset.serviceName = true;
}

void TServiceInfo::__set_serviceLibs(const std::vector<std::string> & val) {
  this->serviceLibs = val;
__isset.serviceLibs = true;
}
std::ostream& operator<<(std::ostream& out, const TServiceInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServiceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serviceName);
          this->__isset.serviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serviceLibs.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->serviceLibs.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->serviceLibs[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serviceLibs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServiceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServiceInfo");

  if (this->__isset.serviceName) {
    xfer += oprot->writeFieldBegin("serviceName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->serviceName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serviceLibs) {
    xfer += oprot->writeFieldBegin("serviceLibs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serviceLibs.size()));
      std::vector<std::string> ::const_iterator _iter5;
      for (_iter5 = this->serviceLibs.begin(); _iter5 != this->serviceLibs.end(); ++_iter5)
      {
        xfer += oprot->writeString((*_iter5));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServiceInfo &a, TServiceInfo &b) {
  using ::std::swap;
  swap(a.serviceName, b.serviceName);
  swap(a.serviceLibs, b.serviceLibs);
  swap(a.__isset, b.__isset);
}

TServiceInfo::TServiceInfo(const TServiceInfo& other6) {
  serviceName = other6.serviceName;
  serviceLibs = other6.serviceLibs;
  __isset = other6.__isset;
}
TServiceInfo& TServiceInfo::operator=(const TServiceInfo& other7) {
  serviceName = other7.serviceName;
  serviceLibs = other7.serviceLibs;
  __isset = other7.__isset;
  return *this;
}
void TServiceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServiceInfo(";
  out << "serviceName="; (__isset.serviceName ? (out << to_string(serviceName)) : (out << "<null>"));
  out << ", " << "serviceLibs="; (__isset.serviceLibs ? (out << to_string(serviceLibs)) : (out << "<null>"));
  out << ")";
}


TServerMetaData::~TServerMetaData() throw() {
}


void TServerMetaData::__set_serverInfo(const std::string& val) {
  this->serverInfo = val;
__isset.serverInfo = true;
}

void TServerMetaData::__set_vmArgs(const std::vector<std::string> & val) {
  this->vmArgs = val;
__isset.vmArgs = true;
}

void TServerMetaData::__set_serviceInfos(const std::vector<TServiceInfo> & val) {
  this->serviceInfos = val;
__isset.serviceInfos = true;
}
std::ostream& operator<<(std::ostream& out, const TServerMetaData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverInfo);
          this->__isset.serverInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vmArgs.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->vmArgs.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readString(this->vmArgs[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vmArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serviceInfos.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->serviceInfos.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->serviceInfos[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serviceInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerMetaData");

  if (this->__isset.serverInfo) {
    xfer += oprot->writeFieldBegin("serverInfo", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->serverInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vmArgs) {
    xfer += oprot->writeFieldBegin("vmArgs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vmArgs.size()));
      std::vector<std::string> ::const_iterator _iter18;
      for (_iter18 = this->vmArgs.begin(); _iter18 != this->vmArgs.end(); ++_iter18)
      {
        xfer += oprot->writeString((*_iter18));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serviceInfos) {
    xfer += oprot->writeFieldBegin("serviceInfos", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serviceInfos.size()));
      std::vector<TServiceInfo> ::const_iterator _iter19;
      for (_iter19 = this->serviceInfos.begin(); _iter19 != this->serviceInfos.end(); ++_iter19)
      {
        xfer += (*_iter19).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerMetaData &a, TServerMetaData &b) {
  using ::std::swap;
  swap(a.serverInfo, b.serverInfo);
  swap(a.vmArgs, b.vmArgs);
  swap(a.serviceInfos, b.serviceInfos);
  swap(a.__isset, b.__isset);
}

TServerMetaData::TServerMetaData(const TServerMetaData& other20) {
  serverInfo = other20.serverInfo;
  vmArgs = other20.vmArgs;
  serviceInfos = other20.serviceInfos;
  __isset = other20.__isset;
}
TServerMetaData& TServerMetaData::operator=(const TServerMetaData& other21) {
  serverInfo = other21.serverInfo;
  vmArgs = other21.vmArgs;
  serviceInfos = other21.serviceInfos;
  __isset = other21.__isset;
  return *this;
}
void TServerMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerMetaData(";
  out << "serverInfo="; (__isset.serverInfo ? (out << to_string(serverInfo)) : (out << "<null>"));
  out << ", " << "vmArgs="; (__isset.vmArgs ? (out << to_string(vmArgs)) : (out << "<null>"));
  out << ", " << "serviceInfos="; (__isset.serviceInfos ? (out << to_string(serviceInfos)) : (out << "<null>"));
  out << ")";
}


TJvmInfo::~TJvmInfo() throw() {
}


void TJvmInfo::__set_version(const int16_t val) {
  this->version = val;
}

void TJvmInfo::__set_vmVersion(const std::string& val) {
  this->vmVersion = val;
__isset.vmVersion = true;
}

void TJvmInfo::__set_gcType(const TJvmGcType::type val) {
  this->gcType = val;
__isset.gcType = true;
}
std::ostream& operator<<(std::ostream& out, const TJvmInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TJvmInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vmVersion);
          this->__isset.vmVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->gcType = (TJvmGcType::type)ecast22;
          this->__isset.gcType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TJvmInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJvmInfo");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.vmVersion) {
    xfer += oprot->writeFieldBegin("vmVersion", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->vmVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gcType) {
    xfer += oprot->writeFieldBegin("gcType", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->gcType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TJvmInfo &a, TJvmInfo &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.vmVersion, b.vmVersion);
  swap(a.gcType, b.gcType);
  swap(a.__isset, b.__isset);
}

TJvmInfo::TJvmInfo(const TJvmInfo& other23) {
  version = other23.version;
  vmVersion = other23.vmVersion;
  gcType = other23.gcType;
  __isset = other23.__isset;
}
TJvmInfo& TJvmInfo::operator=(const TJvmInfo& other24) {
  version = other24.version;
  vmVersion = other24.vmVersion;
  gcType = other24.gcType;
  __isset = other24.__isset;
  return *this;
}
void TJvmInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TJvmInfo(";
  out << "version=" << to_string(version);
  out << ", " << "vmVersion="; (__isset.vmVersion ? (out << to_string(vmVersion)) : (out << "<null>"));
  out << ", " << "gcType="; (__isset.gcType ? (out << to_string(gcType)) : (out << "<null>"));
  out << ")";
}


TAgentInfo::~TAgentInfo() throw() {
}


void TAgentInfo::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TAgentInfo::__set_ip(const std::string& val) {
  this->ip = val;
}

void TAgentInfo::__set_ports(const std::string& val) {
  this->ports = val;
}

void TAgentInfo::__set_agentId(const std::string& val) {
  this->agentId = val;
}

void TAgentInfo::__set_applicationName(const std::string& val) {
  this->applicationName = val;
}

void TAgentInfo::__set_serviceType(const int16_t val) {
  this->serviceType = val;
}

void TAgentInfo::__set_pid(const int32_t val) {
  this->pid = val;
}

void TAgentInfo::__set_agentVersion(const std::string& val) {
  this->agentVersion = val;
}

void TAgentInfo::__set_vmVersion(const std::string& val) {
  this->vmVersion = val;
}

void TAgentInfo::__set_startTimestamp(const int64_t val) {
  this->startTimestamp = val;
}

void TAgentInfo::__set_endTimestamp(const int64_t val) {
  this->endTimestamp = val;
__isset.endTimestamp = true;
}

void TAgentInfo::__set_endStatus(const int32_t val) {
  this->endStatus = val;
__isset.endStatus = true;
}

void TAgentInfo::__set_serverMetaData(const TServerMetaData& val) {
  this->serverMetaData = val;
__isset.serverMetaData = true;
}

void TAgentInfo::__set_jvmInfo(const TJvmInfo& val) {
  this->jvmInfo = val;
__isset.jvmInfo = true;
}
std::ostream& operator<<(std::ostream& out, const TAgentInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAgentInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ports);
          this->__isset.ports = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentId);
          this->__isset.agentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationName);
          this->__isset.applicationName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->serviceType);
          this->__isset.serviceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentVersion);
          this->__isset.agentVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vmVersion);
          this->__isset.vmVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTimestamp);
          this->__isset.startTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTimestamp);
          this->__isset.endTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->endStatus);
          this->__isset.endStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverMetaData.read(iprot);
          this->__isset.serverMetaData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->jvmInfo.read(iprot);
          this->__isset.jvmInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAgentInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentInfo");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ports", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ports);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agentId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->agentId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->applicationName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serviceType", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->serviceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agentVersion", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->agentVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vmVersion", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->vmVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTimestamp", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->startTimestamp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.endTimestamp) {
    xfer += oprot->writeFieldBegin("endTimestamp", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->endTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endStatus) {
    xfer += oprot->writeFieldBegin("endStatus", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->endStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serverMetaData) {
    xfer += oprot->writeFieldBegin("serverMetaData", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->serverMetaData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmInfo) {
    xfer += oprot->writeFieldBegin("jvmInfo", ::apache::thrift::protocol::T_STRUCT, 30);
    xfer += this->jvmInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentInfo &a, TAgentInfo &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.ip, b.ip);
  swap(a.ports, b.ports);
  swap(a.agentId, b.agentId);
  swap(a.applicationName, b.applicationName);
  swap(a.serviceType, b.serviceType);
  swap(a.pid, b.pid);
  swap(a.agentVersion, b.agentVersion);
  swap(a.vmVersion, b.vmVersion);
  swap(a.startTimestamp, b.startTimestamp);
  swap(a.endTimestamp, b.endTimestamp);
  swap(a.endStatus, b.endStatus);
  swap(a.serverMetaData, b.serverMetaData);
  swap(a.jvmInfo, b.jvmInfo);
  swap(a.__isset, b.__isset);
}

TAgentInfo::TAgentInfo(const TAgentInfo& other25) {
  hostname = other25.hostname;
  ip = other25.ip;
  ports = other25.ports;
  agentId = other25.agentId;
  applicationName = other25.applicationName;
  serviceType = other25.serviceType;
  pid = other25.pid;
  agentVersion = other25.agentVersion;
  vmVersion = other25.vmVersion;
  startTimestamp = other25.startTimestamp;
  endTimestamp = other25.endTimestamp;
  endStatus = other25.endStatus;
  serverMetaData = other25.serverMetaData;
  jvmInfo = other25.jvmInfo;
  __isset = other25.__isset;
}
TAgentInfo& TAgentInfo::operator=(const TAgentInfo& other26) {
  hostname = other26.hostname;
  ip = other26.ip;
  ports = other26.ports;
  agentId = other26.agentId;
  applicationName = other26.applicationName;
  serviceType = other26.serviceType;
  pid = other26.pid;
  agentVersion = other26.agentVersion;
  vmVersion = other26.vmVersion;
  startTimestamp = other26.startTimestamp;
  endTimestamp = other26.endTimestamp;
  endStatus = other26.endStatus;
  serverMetaData = other26.serverMetaData;
  jvmInfo = other26.jvmInfo;
  __isset = other26.__isset;
  return *this;
}
void TAgentInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentInfo(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "ports=" << to_string(ports);
  out << ", " << "agentId=" << to_string(agentId);
  out << ", " << "applicationName=" << to_string(applicationName);
  out << ", " << "serviceType=" << to_string(serviceType);
  out << ", " << "pid=" << to_string(pid);
  out << ", " << "agentVersion=" << to_string(agentVersion);
  out << ", " << "vmVersion=" << to_string(vmVersion);
  out << ", " << "startTimestamp=" << to_string(startTimestamp);
  out << ", " << "endTimestamp="; (__isset.endTimestamp ? (out << to_string(endTimestamp)) : (out << "<null>"));
  out << ", " << "endStatus="; (__isset.endStatus ? (out << to_string(endStatus)) : (out << "<null>"));
  out << ", " << "serverMetaData="; (__isset.serverMetaData ? (out << to_string(serverMetaData)) : (out << "<null>"));
  out << ", " << "jvmInfo="; (__isset.jvmInfo ? (out << to_string(jvmInfo)) : (out << "<null>"));
  out << ")";
}


TJvmGcDetailed::~TJvmGcDetailed() throw() {
}


void TJvmGcDetailed::__set_jvmGcNewCount(const int64_t val) {
  this->jvmGcNewCount = val;
__isset.jvmGcNewCount = true;
}

void TJvmGcDetailed::__set_jvmGcNewTime(const int64_t val) {
  this->jvmGcNewTime = val;
__isset.jvmGcNewTime = true;
}

void TJvmGcDetailed::__set_jvmPoolCodeCacheUsed(const double val) {
  this->jvmPoolCodeCacheUsed = val;
__isset.jvmPoolCodeCacheUsed = true;
}

void TJvmGcDetailed::__set_jvmPoolNewGenUsed(const double val) {
  this->jvmPoolNewGenUsed = val;
__isset.jvmPoolNewGenUsed = true;
}

void TJvmGcDetailed::__set_jvmPoolOldGenUsed(const double val) {
  this->jvmPoolOldGenUsed = val;
__isset.jvmPoolOldGenUsed = true;
}

void TJvmGcDetailed::__set_jvmPoolSurvivorSpaceUsed(const double val) {
  this->jvmPoolSurvivorSpaceUsed = val;
__isset.jvmPoolSurvivorSpaceUsed = true;
}

void TJvmGcDetailed::__set_jvmPoolPermGenUsed(const double val) {
  this->jvmPoolPermGenUsed = val;
__isset.jvmPoolPermGenUsed = true;
}

void TJvmGcDetailed::__set_jvmPoolMetaspaceUsed(const double val) {
  this->jvmPoolMetaspaceUsed = val;
__isset.jvmPoolMetaspaceUsed = true;
}
std::ostream& operator<<(std::ostream& out, const TJvmGcDetailed& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TJvmGcDetailed::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmGcNewCount);
          this->__isset.jvmGcNewCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmGcNewTime);
          this->__isset.jvmGcNewTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolCodeCacheUsed);
          this->__isset.jvmPoolCodeCacheUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolNewGenUsed);
          this->__isset.jvmPoolNewGenUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolOldGenUsed);
          this->__isset.jvmPoolOldGenUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolSurvivorSpaceUsed);
          this->__isset.jvmPoolSurvivorSpaceUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolPermGenUsed);
          this->__isset.jvmPoolPermGenUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmPoolMetaspaceUsed);
          this->__isset.jvmPoolMetaspaceUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TJvmGcDetailed::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJvmGcDetailed");

  if (this->__isset.jvmGcNewCount) {
    xfer += oprot->writeFieldBegin("jvmGcNewCount", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->jvmGcNewCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmGcNewTime) {
    xfer += oprot->writeFieldBegin("jvmGcNewTime", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->jvmGcNewTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolCodeCacheUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolCodeCacheUsed", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->jvmPoolCodeCacheUsed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolNewGenUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolNewGenUsed", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->jvmPoolNewGenUsed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolOldGenUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolOldGenUsed", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->jvmPoolOldGenUsed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolSurvivorSpaceUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolSurvivorSpaceUsed", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->jvmPoolSurvivorSpaceUsed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolPermGenUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolPermGenUsed", ::apache::thrift::protocol::T_DOUBLE, 7);
    xfer += oprot->writeDouble(this->jvmPoolPermGenUsed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jvmPoolMetaspaceUsed) {
    xfer += oprot->writeFieldBegin("jvmPoolMetaspaceUsed", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->jvmPoolMetaspaceUsed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TJvmGcDetailed &a, TJvmGcDetailed &b) {
  using ::std::swap;
  swap(a.jvmGcNewCount, b.jvmGcNewCount);
  swap(a.jvmGcNewTime, b.jvmGcNewTime);
  swap(a.jvmPoolCodeCacheUsed, b.jvmPoolCodeCacheUsed);
  swap(a.jvmPoolNewGenUsed, b.jvmPoolNewGenUsed);
  swap(a.jvmPoolOldGenUsed, b.jvmPoolOldGenUsed);
  swap(a.jvmPoolSurvivorSpaceUsed, b.jvmPoolSurvivorSpaceUsed);
  swap(a.jvmPoolPermGenUsed, b.jvmPoolPermGenUsed);
  swap(a.jvmPoolMetaspaceUsed, b.jvmPoolMetaspaceUsed);
  swap(a.__isset, b.__isset);
}

TJvmGcDetailed::TJvmGcDetailed(const TJvmGcDetailed& other27) {
  jvmGcNewCount = other27.jvmGcNewCount;
  jvmGcNewTime = other27.jvmGcNewTime;
  jvmPoolCodeCacheUsed = other27.jvmPoolCodeCacheUsed;
  jvmPoolNewGenUsed = other27.jvmPoolNewGenUsed;
  jvmPoolOldGenUsed = other27.jvmPoolOldGenUsed;
  jvmPoolSurvivorSpaceUsed = other27.jvmPoolSurvivorSpaceUsed;
  jvmPoolPermGenUsed = other27.jvmPoolPermGenUsed;
  jvmPoolMetaspaceUsed = other27.jvmPoolMetaspaceUsed;
  __isset = other27.__isset;
}
TJvmGcDetailed& TJvmGcDetailed::operator=(const TJvmGcDetailed& other28) {
  jvmGcNewCount = other28.jvmGcNewCount;
  jvmGcNewTime = other28.jvmGcNewTime;
  jvmPoolCodeCacheUsed = other28.jvmPoolCodeCacheUsed;
  jvmPoolNewGenUsed = other28.jvmPoolNewGenUsed;
  jvmPoolOldGenUsed = other28.jvmPoolOldGenUsed;
  jvmPoolSurvivorSpaceUsed = other28.jvmPoolSurvivorSpaceUsed;
  jvmPoolPermGenUsed = other28.jvmPoolPermGenUsed;
  jvmPoolMetaspaceUsed = other28.jvmPoolMetaspaceUsed;
  __isset = other28.__isset;
  return *this;
}
void TJvmGcDetailed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TJvmGcDetailed(";
  out << "jvmGcNewCount="; (__isset.jvmGcNewCount ? (out << to_string(jvmGcNewCount)) : (out << "<null>"));
  out << ", " << "jvmGcNewTime="; (__isset.jvmGcNewTime ? (out << to_string(jvmGcNewTime)) : (out << "<null>"));
  out << ", " << "jvmPoolCodeCacheUsed="; (__isset.jvmPoolCodeCacheUsed ? (out << to_string(jvmPoolCodeCacheUsed)) : (out << "<null>"));
  out << ", " << "jvmPoolNewGenUsed="; (__isset.jvmPoolNewGenUsed ? (out << to_string(jvmPoolNewGenUsed)) : (out << "<null>"));
  out << ", " << "jvmPoolOldGenUsed="; (__isset.jvmPoolOldGenUsed ? (out << to_string(jvmPoolOldGenUsed)) : (out << "<null>"));
  out << ", " << "jvmPoolSurvivorSpaceUsed="; (__isset.jvmPoolSurvivorSpaceUsed ? (out << to_string(jvmPoolSurvivorSpaceUsed)) : (out << "<null>"));
  out << ", " << "jvmPoolPermGenUsed="; (__isset.jvmPoolPermGenUsed ? (out << to_string(jvmPoolPermGenUsed)) : (out << "<null>"));
  out << ", " << "jvmPoolMetaspaceUsed="; (__isset.jvmPoolMetaspaceUsed ? (out << to_string(jvmPoolMetaspaceUsed)) : (out << "<null>"));
  out << ")";
}


TJvmGc::~TJvmGc() throw() {
}


void TJvmGc::__set_type(const TJvmGcType::type val) {
  this->type = val;
}

void TJvmGc::__set_jvmMemoryHeapUsed(const int64_t val) {
  this->jvmMemoryHeapUsed = val;
}

void TJvmGc::__set_jvmMemoryHeapMax(const int64_t val) {
  this->jvmMemoryHeapMax = val;
}

void TJvmGc::__set_jvmMemoryNonHeapUsed(const int64_t val) {
  this->jvmMemoryNonHeapUsed = val;
}

void TJvmGc::__set_jvmMemoryNonHeapMax(const int64_t val) {
  this->jvmMemoryNonHeapMax = val;
}

void TJvmGc::__set_jvmGcOldCount(const int64_t val) {
  this->jvmGcOldCount = val;
}

void TJvmGc::__set_jvmGcOldTime(const int64_t val) {
  this->jvmGcOldTime = val;
}

void TJvmGc::__set_jvmGcDetailed(const TJvmGcDetailed& val) {
  this->jvmGcDetailed = val;
__isset.jvmGcDetailed = true;
}
std::ostream& operator<<(std::ostream& out, const TJvmGc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TJvmGc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->type = (TJvmGcType::type)ecast29;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmMemoryHeapUsed);
          this->__isset.jvmMemoryHeapUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmMemoryHeapMax);
          this->__isset.jvmMemoryHeapMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmMemoryNonHeapUsed);
          this->__isset.jvmMemoryNonHeapUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmMemoryNonHeapMax);
          this->__isset.jvmMemoryNonHeapMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmGcOldCount);
          this->__isset.jvmGcOldCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->jvmGcOldTime);
          this->__isset.jvmGcOldTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->jvmGcDetailed.read(iprot);
          this->__isset.jvmGcDetailed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TJvmGc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJvmGc");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmMemoryHeapUsed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->jvmMemoryHeapUsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmMemoryHeapMax", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->jvmMemoryHeapMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmMemoryNonHeapUsed", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->jvmMemoryNonHeapUsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmMemoryNonHeapMax", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->jvmMemoryNonHeapMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmGcOldCount", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->jvmGcOldCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jvmGcOldTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->jvmGcOldTime);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.jvmGcDetailed) {
    xfer += oprot->writeFieldBegin("jvmGcDetailed", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->jvmGcDetailed.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TJvmGc &a, TJvmGc &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.jvmMemoryHeapUsed, b.jvmMemoryHeapUsed);
  swap(a.jvmMemoryHeapMax, b.jvmMemoryHeapMax);
  swap(a.jvmMemoryNonHeapUsed, b.jvmMemoryNonHeapUsed);
  swap(a.jvmMemoryNonHeapMax, b.jvmMemoryNonHeapMax);
  swap(a.jvmGcOldCount, b.jvmGcOldCount);
  swap(a.jvmGcOldTime, b.jvmGcOldTime);
  swap(a.jvmGcDetailed, b.jvmGcDetailed);
  swap(a.__isset, b.__isset);
}

TJvmGc::TJvmGc(const TJvmGc& other30) {
  type = other30.type;
  jvmMemoryHeapUsed = other30.jvmMemoryHeapUsed;
  jvmMemoryHeapMax = other30.jvmMemoryHeapMax;
  jvmMemoryNonHeapUsed = other30.jvmMemoryNonHeapUsed;
  jvmMemoryNonHeapMax = other30.jvmMemoryNonHeapMax;
  jvmGcOldCount = other30.jvmGcOldCount;
  jvmGcOldTime = other30.jvmGcOldTime;
  jvmGcDetailed = other30.jvmGcDetailed;
  __isset = other30.__isset;
}
TJvmGc& TJvmGc::operator=(const TJvmGc& other31) {
  type = other31.type;
  jvmMemoryHeapUsed = other31.jvmMemoryHeapUsed;
  jvmMemoryHeapMax = other31.jvmMemoryHeapMax;
  jvmMemoryNonHeapUsed = other31.jvmMemoryNonHeapUsed;
  jvmMemoryNonHeapMax = other31.jvmMemoryNonHeapMax;
  jvmGcOldCount = other31.jvmGcOldCount;
  jvmGcOldTime = other31.jvmGcOldTime;
  jvmGcDetailed = other31.jvmGcDetailed;
  __isset = other31.__isset;
  return *this;
}
void TJvmGc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TJvmGc(";
  out << "type=" << to_string(type);
  out << ", " << "jvmMemoryHeapUsed=" << to_string(jvmMemoryHeapUsed);
  out << ", " << "jvmMemoryHeapMax=" << to_string(jvmMemoryHeapMax);
  out << ", " << "jvmMemoryNonHeapUsed=" << to_string(jvmMemoryNonHeapUsed);
  out << ", " << "jvmMemoryNonHeapMax=" << to_string(jvmMemoryNonHeapMax);
  out << ", " << "jvmGcOldCount=" << to_string(jvmGcOldCount);
  out << ", " << "jvmGcOldTime=" << to_string(jvmGcOldTime);
  out << ", " << "jvmGcDetailed="; (__isset.jvmGcDetailed ? (out << to_string(jvmGcDetailed)) : (out << "<null>"));
  out << ")";
}


TCpuLoad::~TCpuLoad() throw() {
}


void TCpuLoad::__set_jvmCpuLoad(const double val) {
  this->jvmCpuLoad = val;
__isset.jvmCpuLoad = true;
}

void TCpuLoad::__set_systemCpuLoad(const double val) {
  this->systemCpuLoad = val;
__isset.systemCpuLoad = true;
}
std::ostream& operator<<(std::ostream& out, const TCpuLoad& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCpuLoad::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->jvmCpuLoad);
          this->__isset.jvmCpuLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->systemCpuLoad);
          this->__isset.systemCpuLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCpuLoad::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCpuLoad");

  if (this->__isset.jvmCpuLoad) {
    xfer += oprot->writeFieldBegin("jvmCpuLoad", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->jvmCpuLoad);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.systemCpuLoad) {
    xfer += oprot->writeFieldBegin("systemCpuLoad", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->systemCpuLoad);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCpuLoad &a, TCpuLoad &b) {
  using ::std::swap;
  swap(a.jvmCpuLoad, b.jvmCpuLoad);
  swap(a.systemCpuLoad, b.systemCpuLoad);
  swap(a.__isset, b.__isset);
}

TCpuLoad::TCpuLoad(const TCpuLoad& other32) {
  jvmCpuLoad = other32.jvmCpuLoad;
  systemCpuLoad = other32.systemCpuLoad;
  __isset = other32.__isset;
}
TCpuLoad& TCpuLoad::operator=(const TCpuLoad& other33) {
  jvmCpuLoad = other33.jvmCpuLoad;
  systemCpuLoad = other33.systemCpuLoad;
  __isset = other33.__isset;
  return *this;
}
void TCpuLoad::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCpuLoad(";
  out << "jvmCpuLoad="; (__isset.jvmCpuLoad ? (out << to_string(jvmCpuLoad)) : (out << "<null>"));
  out << ", " << "systemCpuLoad="; (__isset.systemCpuLoad ? (out << to_string(systemCpuLoad)) : (out << "<null>"));
  out << ")";
}


TTransaction::~TTransaction() throw() {
}


void TTransaction::__set_sampledNewCount(const int64_t val) {
  this->sampledNewCount = val;
__isset.sampledNewCount = true;
}

void TTransaction::__set_sampledContinuationCount(const int64_t val) {
  this->sampledContinuationCount = val;
__isset.sampledContinuationCount = true;
}

void TTransaction::__set_unsampledNewCount(const int64_t val) {
  this->unsampledNewCount = val;
__isset.unsampledNewCount = true;
}

void TTransaction::__set_unsampledContinuationCount(const int64_t val) {
  this->unsampledContinuationCount = val;
__isset.unsampledContinuationCount = true;
}
std::ostream& operator<<(std::ostream& out, const TTransaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTransaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sampledNewCount);
          this->__isset.sampledNewCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sampledContinuationCount);
          this->__isset.sampledContinuationCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unsampledNewCount);
          this->__isset.unsampledNewCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unsampledContinuationCount);
          this->__isset.unsampledContinuationCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTransaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTransaction");

  if (this->__isset.sampledNewCount) {
    xfer += oprot->writeFieldBegin("sampledNewCount", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->sampledNewCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sampledContinuationCount) {
    xfer += oprot->writeFieldBegin("sampledContinuationCount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sampledContinuationCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unsampledNewCount) {
    xfer += oprot->writeFieldBegin("unsampledNewCount", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->unsampledNewCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unsampledContinuationCount) {
    xfer += oprot->writeFieldBegin("unsampledContinuationCount", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->unsampledContinuationCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransaction &a, TTransaction &b) {
  using ::std::swap;
  swap(a.sampledNewCount, b.sampledNewCount);
  swap(a.sampledContinuationCount, b.sampledContinuationCount);
  swap(a.unsampledNewCount, b.unsampledNewCount);
  swap(a.unsampledContinuationCount, b.unsampledContinuationCount);
  swap(a.__isset, b.__isset);
}

TTransaction::TTransaction(const TTransaction& other34) {
  sampledNewCount = other34.sampledNewCount;
  sampledContinuationCount = other34.sampledContinuationCount;
  unsampledNewCount = other34.unsampledNewCount;
  unsampledContinuationCount = other34.unsampledContinuationCount;
  __isset = other34.__isset;
}
TTransaction& TTransaction::operator=(const TTransaction& other35) {
  sampledNewCount = other35.sampledNewCount;
  sampledContinuationCount = other35.sampledContinuationCount;
  unsampledNewCount = other35.unsampledNewCount;
  unsampledContinuationCount = other35.unsampledContinuationCount;
  __isset = other35.__isset;
  return *this;
}
void TTransaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTransaction(";
  out << "sampledNewCount="; (__isset.sampledNewCount ? (out << to_string(sampledNewCount)) : (out << "<null>"));
  out << ", " << "sampledContinuationCount="; (__isset.sampledContinuationCount ? (out << to_string(sampledContinuationCount)) : (out << "<null>"));
  out << ", " << "unsampledNewCount="; (__isset.unsampledNewCount ? (out << to_string(unsampledNewCount)) : (out << "<null>"));
  out << ", " << "unsampledContinuationCount="; (__isset.unsampledContinuationCount ? (out << to_string(unsampledContinuationCount)) : (out << "<null>"));
  out << ")";
}


TActiveTraceHistogram::~TActiveTraceHistogram() throw() {
}


void TActiveTraceHistogram::__set_version(const int16_t val) {
  this->version = val;
}

void TActiveTraceHistogram::__set_histogramSchemaType(const int32_t val) {
  this->histogramSchemaType = val;
__isset.histogramSchemaType = true;
}

void TActiveTraceHistogram::__set_activeTraceCount(const std::vector<int32_t> & val) {
  this->activeTraceCount = val;
__isset.activeTraceCount = true;
}
std::ostream& operator<<(std::ostream& out, const TActiveTraceHistogram& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TActiveTraceHistogram::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->histogramSchemaType);
          this->__isset.histogramSchemaType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activeTraceCount.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->activeTraceCount.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI32(this->activeTraceCount[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.activeTraceCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TActiveTraceHistogram::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TActiveTraceHistogram");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.histogramSchemaType) {
    xfer += oprot->writeFieldBegin("histogramSchemaType", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->histogramSchemaType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeTraceCount) {
    xfer += oprot->writeFieldBegin("activeTraceCount", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->activeTraceCount.size()));
      std::vector<int32_t> ::const_iterator _iter41;
      for (_iter41 = this->activeTraceCount.begin(); _iter41 != this->activeTraceCount.end(); ++_iter41)
      {
        xfer += oprot->writeI32((*_iter41));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TActiveTraceHistogram &a, TActiveTraceHistogram &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.histogramSchemaType, b.histogramSchemaType);
  swap(a.activeTraceCount, b.activeTraceCount);
  swap(a.__isset, b.__isset);
}

TActiveTraceHistogram::TActiveTraceHistogram(const TActiveTraceHistogram& other42) {
  version = other42.version;
  histogramSchemaType = other42.histogramSchemaType;
  activeTraceCount = other42.activeTraceCount;
  __isset = other42.__isset;
}
TActiveTraceHistogram& TActiveTraceHistogram::operator=(const TActiveTraceHistogram& other43) {
  version = other43.version;
  histogramSchemaType = other43.histogramSchemaType;
  activeTraceCount = other43.activeTraceCount;
  __isset = other43.__isset;
  return *this;
}
void TActiveTraceHistogram::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TActiveTraceHistogram(";
  out << "version=" << to_string(version);
  out << ", " << "histogramSchemaType="; (__isset.histogramSchemaType ? (out << to_string(histogramSchemaType)) : (out << "<null>"));
  out << ", " << "activeTraceCount="; (__isset.activeTraceCount ? (out << to_string(activeTraceCount)) : (out << "<null>"));
  out << ")";
}


TActiveTrace::~TActiveTrace() throw() {
}


void TActiveTrace::__set_histogram(const TActiveTraceHistogram& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const TActiveTrace& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TActiveTrace::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->histogram.read(iprot);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TActiveTrace::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TActiveTrace");

  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->histogram.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TActiveTrace &a, TActiveTrace &b) {
  using ::std::swap;
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

TActiveTrace::TActiveTrace(const TActiveTrace& other44) {
  histogram = other44.histogram;
  __isset = other44.__isset;
}
TActiveTrace& TActiveTrace::operator=(const TActiveTrace& other45) {
  histogram = other45.histogram;
  __isset = other45.__isset;
  return *this;
}
void TActiveTrace::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TActiveTrace(";
  out << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


TAgentStat::~TAgentStat() throw() {
}


void TAgentStat::__set_agentId(const std::string& val) {
  this->agentId = val;
__isset.agentId = true;
}

void TAgentStat::__set_startTimestamp(const int64_t val) {
  this->startTimestamp = val;
__isset.startTimestamp = true;
}

void TAgentStat::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TAgentStat::__set_collectInterval(const int64_t val) {
  this->collectInterval = val;
__isset.collectInterval = true;
}

void TAgentStat::__set_gc(const TJvmGc& val) {
  this->gc = val;
__isset.gc = true;
}

void TAgentStat::__set_cpuLoad(const TCpuLoad& val) {
  this->cpuLoad = val;
__isset.cpuLoad = true;
}

void TAgentStat::__set_transaction(const TTransaction& val) {
  this->transaction = val;
__isset.transaction = true;
}

void TAgentStat::__set_activeTrace(const TActiveTrace& val) {
  this->activeTrace = val;
__isset.activeTrace = true;
}

void TAgentStat::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}
std::ostream& operator<<(std::ostream& out, const TAgentStat& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAgentStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentId);
          this->__isset.agentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTimestamp);
          this->__isset.startTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->collectInterval);
          this->__isset.collectInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gc.read(iprot);
          this->__isset.gc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cpuLoad.read(iprot);
          this->__isset.cpuLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transaction.read(iprot);
          this->__isset.transaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->activeTrace.read(iprot);
          this->__isset.activeTrace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 200:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAgentStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentStat");

  if (this->__isset.agentId) {
    xfer += oprot->writeFieldBegin("agentId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->agentId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startTimestamp) {
    xfer += oprot->writeFieldBegin("startTimestamp", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->startTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.collectInterval) {
    xfer += oprot->writeFieldBegin("collectInterval", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->collectInterval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gc) {
    xfer += oprot->writeFieldBegin("gc", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->gc.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpuLoad) {
    xfer += oprot->writeFieldBegin("cpuLoad", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->cpuLoad.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transaction) {
    xfer += oprot->writeFieldBegin("transaction", ::apache::thrift::protocol::T_STRUCT, 30);
    xfer += this->transaction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeTrace) {
    xfer += oprot->writeFieldBegin("activeTrace", ::apache::thrift::protocol::T_STRUCT, 40);
    xfer += this->activeTrace.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 200);
    xfer += oprot->writeString(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentStat &a, TAgentStat &b) {
  using ::std::swap;
  swap(a.agentId, b.agentId);
  swap(a.startTimestamp, b.startTimestamp);
  swap(a.timestamp, b.timestamp);
  swap(a.collectInterval, b.collectInterval);
  swap(a.gc, b.gc);
  swap(a.cpuLoad, b.cpuLoad);
  swap(a.transaction, b.transaction);
  swap(a.activeTrace, b.activeTrace);
  swap(a.metadata, b.metadata);
  swap(a.__isset, b.__isset);
}

TAgentStat::TAgentStat(const TAgentStat& other46) {
  agentId = other46.agentId;
  startTimestamp = other46.startTimestamp;
  timestamp = other46.timestamp;
  collectInterval = other46.collectInterval;
  gc = other46.gc;
  cpuLoad = other46.cpuLoad;
  transaction = other46.transaction;
  activeTrace = other46.activeTrace;
  metadata = other46.metadata;
  __isset = other46.__isset;
}
TAgentStat& TAgentStat::operator=(const TAgentStat& other47) {
  agentId = other47.agentId;
  startTimestamp = other47.startTimestamp;
  timestamp = other47.timestamp;
  collectInterval = other47.collectInterval;
  gc = other47.gc;
  cpuLoad = other47.cpuLoad;
  transaction = other47.transaction;
  activeTrace = other47.activeTrace;
  metadata = other47.metadata;
  __isset = other47.__isset;
  return *this;
}
void TAgentStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentStat(";
  out << "agentId="; (__isset.agentId ? (out << to_string(agentId)) : (out << "<null>"));
  out << ", " << "startTimestamp="; (__isset.startTimestamp ? (out << to_string(startTimestamp)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "collectInterval="; (__isset.collectInterval ? (out << to_string(collectInterval)) : (out << "<null>"));
  out << ", " << "gc="; (__isset.gc ? (out << to_string(gc)) : (out << "<null>"));
  out << ", " << "cpuLoad="; (__isset.cpuLoad ? (out << to_string(cpuLoad)) : (out << "<null>"));
  out << ", " << "transaction="; (__isset.transaction ? (out << to_string(transaction)) : (out << "<null>"));
  out << ", " << "activeTrace="; (__isset.activeTrace ? (out << to_string(activeTrace)) : (out << "<null>"));
  out << ", " << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ")";
}


TAgentStatBatch::~TAgentStatBatch() throw() {
}


void TAgentStatBatch::__set_agentId(const std::string& val) {
  this->agentId = val;
}

void TAgentStatBatch::__set_startTimestamp(const int64_t val) {
  this->startTimestamp = val;
}

void TAgentStatBatch::__set_agentStats(const std::vector<TAgentStat> & val) {
  this->agentStats = val;
}
std::ostream& operator<<(std::ostream& out, const TAgentStatBatch& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAgentStatBatch::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentId);
          this->__isset.agentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTimestamp);
          this->__isset.startTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->agentStats.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->agentStats.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->agentStats[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.agentStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAgentStatBatch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentStatBatch");

  xfer += oprot->writeFieldBegin("agentId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->agentId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTimestamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->startTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agentStats", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->agentStats.size()));
    std::vector<TAgentStat> ::const_iterator _iter53;
    for (_iter53 = this->agentStats.begin(); _iter53 != this->agentStats.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentStatBatch &a, TAgentStatBatch &b) {
  using ::std::swap;
  swap(a.agentId, b.agentId);
  swap(a.startTimestamp, b.startTimestamp);
  swap(a.agentStats, b.agentStats);
  swap(a.__isset, b.__isset);
}

TAgentStatBatch::TAgentStatBatch(const TAgentStatBatch& other54) {
  agentId = other54.agentId;
  startTimestamp = other54.startTimestamp;
  agentStats = other54.agentStats;
  __isset = other54.__isset;
}
TAgentStatBatch& TAgentStatBatch::operator=(const TAgentStatBatch& other55) {
  agentId = other55.agentId;
  startTimestamp = other55.startTimestamp;
  agentStats = other55.agentStats;
  __isset = other55.__isset;
  return *this;
}
void TAgentStatBatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentStatBatch(";
  out << "agentId=" << to_string(agentId);
  out << ", " << "startTimestamp=" << to_string(startTimestamp);
  out << ", " << "agentStats=" << to_string(agentStats);
  out << ")";
}


